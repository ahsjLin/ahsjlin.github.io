<html>
<head>
<title>binary tree</title>

<!-- latex math javascript-->
<script 
id="MathJax-script"
async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
</script>
<!-- open raw text -->
<script charset="utf-8">
function graph(name){
	var file = "src/" + name;
	window.open(file);
}
</script>

<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/a/blue.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/table/block.css">



</head>
<body>
<h2>二元樹和AVL樹</h2>
<a href="pdf/binary_search_tree.html" target="_blank">二元樹創建和刪除(利用Inorder traversal找繼承者)</a>
<br>
<a href="pdf/AVL_tree.html" target="_blank">AVL二元平衡樹</a><br>
<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank">AVL Tree 模擬器</a>
<hr>
<h2>Properties of Binary tree</h2>
V: vertex<br>
E: edge<br>
<br>
\[
V=E+1
\]<br>
<b>proof</b>
<br>
Using induction.<br>
<ol>
<li>
Let V=1,<br>
Since E=0<br>
Hence V=E+1
</li>
<li>
Suppose
\(
1\leq k\leq n
\rightarrow 
V=k, E=k-1
\) is right.
</li>
<li>
To proof V=k+1 is right.<br>
E=(k-1)+1=k.<br>
\(V\) split to 
\( \{V_0, V_1, V_2,\dots, V_k \}\)<br>
\( V_0 \) is root.<br>
\( \{V_1, V_2,\dots,V_k \}\) is set of sum of vertex of subtree of \( V_0 \).<br>
\(
E=E_1+E_2+\dots+E_k+k
\)
<br>
The k is number of connecting of \(\{V_1,V_2,\dots,V_k\}\)
<br>
<br>
\(
V_1 = E_1 +1
\)<br>
\(
V_2 = E_2 +1
\)<br>
\(
\dots
\)<br>
\(
V_k = E_k +1
\)<br>
<br>
\( V_1+ V_2+\dots+V_k \)<br>
\(
=
(E_1+1)+(E_2+1)+\dots+(E_k+1)=E_1+E_2+\dots+E_k+k
\)<br>
\(
\rightarrow 
V = V_0 +(V_1+V_2+\dots+V_k), \because V_0 \text{ is root}
\therefore V_0= 1
\)
<br>
\(
\rightarrow 
V=(V_1+V_2+\dots+V_k)+1
\)<br>
\(
\rightarrow 
V=(E_1+E_2+\dots+E_k+k)+1
\)<br>
\(
\rightarrow 
V=E+1
\)<br>
\(
\because E=k
\)<br>
\(
\therefore V=k+1
\)<br>
Q.E.D.
</li>
</ol>
<hr>
<h2>skew tree && complete binary tree</h2>
<img src="img/skew_complete.png" alt=""/>
<br>
The nodes on level i are up to
\[
2^{i-1},i\geq 1
\]
<hr>
The binary tree have k depth.
The number of nodes are up to
\[
2^k-1, k\geq 1
\]
<hr>
On binary tree.<br>
Suppose number of degree 0 nodes is \( n_0 \), <br>
number of degree 1 nodes is \( n_1 \), <br>
number of degree 2 nodes is \( n_2 \), <br>
number of all nodes is \( n \).<br>
\[
n_0 = n_2+1
\]
<b>proof</b><br>
\(
n=n_0+n_1+n_2
\)<br>
Let \( B \) is the number of edges.
\(
n=B+1
\)<br>
\(
\rightarrow 
B = n_1+2n_2
\)<br>
\(
\rightarrow 
n=n_1+2n_2+1
\)<br>
\(
\rightarrow 
n_0+n_1+n_2 = n_1+2n_2+1
\)<br>
\(
\therefore
n_0=n_2+1
\)
<hr>
<h2>Full binary tree</h2>
Fulled all nodes on binary tree.<br>
Therefore, number of nodes are \( 2^k-1 , k\geq 0\)
<hr>
<h2>depth of complete / full binary tree</h2>
\[
\lceil \log_{2}(n+1) \rceil
\]
<hr>
<h2>formal binary tree</h2>
<b>Internal node</b> is the node of tree and is not the leaf.<br>
All Internal nodes have two child nodes that named <b>formal binary tree</b>.
<hr>
<h2>put binary tree into array</h2>
Label of node is same as array index(omitted index 0).<br>
Suppose the node i (\( i\neq 1 \))<br>
Its label of parent is \( i/2 \). <br>
<br>
Suppose the node i.<br>
Its label of left child is \( 2i \).<br>
\( 2i>n \rightarrow \not\exists \text{left child}\).
<br>
<br>
Suppose the node i.<br>
Its label of right child is \( 2i+1 \).<br>
\( 2i+1>n \rightarrow \not\exists \text{right child}\).<br>
<br>
<h2>缺點</h2>
如果不是完備/完滿二元樹，會造成陣列空間的浪費。<br>
節點的新增、刪除會搬動大部分的節點，造成cpu的負擔，使用
link list可以解決這個問題。<br>
<hr>
<h2>link list on binary tree</h2>
<h3>code(c)</h3>
<embed width="400" src="src/binary_tree.c" type=""><br>
If add a pointer to parent.<br>
Modify like as:<br>
<h3>code(c)</h3>
<embed width="400" src="src/binary_tree_add_parent.c" type=""><br>

<hr>
<h2>Order traversal</h2>
Suppose code:<br>
<h3>code(c)</h3>
<embed width="400" src="src/binary_tree.c" type=""><br>
<table>
	<tr>
<td>
<ul style="line-height: 150%;">
	<li>(<b>LVR</b>)inorder traversal / infix notation<br>
<b>order: </b>DBFEGAC
<br>
<a href="https://github.com/ahsjLin/cpp_Tree_LVR/raw/main/spanning_tree.exe" target="_blank">c++小程式</a>(no harm
	</li>
	<li>(<b>LRV</b>)postorder traversal / postfix notation<br>
<b>order: </b>DFGEBCA
	</li>
	<li>(<b>VLR</b>)preorder traversal / prefix notation<br>
<b>order: </b>ABDEFGC
	</li>
</ul>
</td>
<td>
<img src="img/order.png" alt=""/><br>
<br>
<button onclick="graph('order.txt')">graph</button>
</td>
	</tr>
<tr>
<td>
The formulae on binary tree. 
<br>
\[
[(A+B)*C]+[(E-F)/D]
\]
</td>
<td>
<img src="img/formulae.png" alt=""/><br>
<br>
<button onclick="graph('formulae.txt')">graph</button>

</td>
</tr>
<tr>
<td>
<h2>Inorder / Infix (LVR)</h2>
<b>Order:</b><br>
A + B * C + [ (E - F) / D ]

</td>
<td rowspan="3">
<h3>code(c)</h3>
<embed width="400" height="500" src="src/order_formulae.c" type="">
</td>
</tr>

<tr>
<td>
<h2>Postorder / postfix (LRV)</h2>
<b>Order:</b><br>
A B + C * E F - D / +

</td>
</tr>

<tr>
<td>
<h2>Preorder / prefix (VLR)</h2>
<b>Order:</b><br>
+ * + A B C / - E F D

</td>
</tr>
</table>
還原技巧:<br>
括號起來的地方當作一個變數。<br>
postorder: 遇兩個變數再遇一個操作數就括號起來。<br>
preorder: 遇一個操作數再遇兩個變數就括號起來。<br>


<hr>
<h2>Copy function</h2>
<h3>code(c)</h3>
<embed width="600" height="400" src="src/BTree_copy.c" type="">
<hr>
<h2>Equal function</h2>
<h3>code(c)</h3>
<embed width="600" height="400" src="src/BTree_equal.c" type="">

<hr>
<h2>threaded binary tree</h2>
針對樹葉節點的空指標可以有效利用。<br>
使得有些運算能加快(走訪)。<br>
<img src="img/threaded_btree.png" alt=""/><br>
<table>
<tr>
<td>
<h3>code(c)</h3>
<embed width="600" height="600" src="src/threaded_btree.c" type="">
</td>
<td>
<img src="img/threaded_btree_.png" alt=""/><br>
開頭空白節點的利用<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/iWdw1kvp3ow?start=9612" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</td>
</tr>
</table>
一旦threaded binary tree 建立完成，infix order(LVR)的走訪就簡單多了<br>
順序: 
G D H B A I E C F<br>
<br>
解釋:<br>
如果右引線為true的話，return 右子樹node的記憶體位址，<br>
否則(執行 while)會找右子樹的最左樹葉，<br>
並return 該樹葉的記憶體位址。<br>

<br>
nextThreadedNode代開頭空白節點return G node的記憶體位址<br>
nextThreadedNode代G node的記憶體位址 return D node的記憶體位址<br>
以此類類推。
<br>
<h3>
Infix order(中序走訪)<br>
code(c):
</h3>
<embed width="400" height="200" src="src/threaded_inorder.c" type=""><br>
<br>





<hr>
<footer>
<h2>Reference</h2>
徐熊健 - 資料結構與演算法
</footer>
</body>
</html>
