<html>
<head>
<title></title>

<!-- latex math javascript-->
<script 
id="MathJax-script"
async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
</script>


<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/a/blue.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/table/block.css">



</head>
<body>
<h2>Address Binding</h2>
<p>
To be executed, the program must be brought into 
memory and placed within a process.
</p>
<p>
A compiler will typically bind these symbolic addresses to
relocatable addresses.
</p>
<p>
Classically, the binding of instructions and
data to memory addresses can be done at any
step along the way.
<ul>
<li>
<b>Compile time</b>
<br>
<div>
If you know at comile time where the process will<br>
reside in memory, then absolute code can be generated.
</div>
<div>
If the starting location changes, then it will be necessary<br>
to recompile this code.
</div>
</li>
<li>
<b>Load time</b><br>
If it is not known at compile time where the process<br>
will reside in memory, then the compiler must generate
<b>relocatable code.</b>
</li>
<li>
<b>Execution time</b><br>
If the process can be moved during its execution from one<br>
memory segment to another, then binding must be delayed until//
run time.<br>
Special hardware must be available for this scheme to work.
</li>
</ul>
</p>
<hr>
<h2>Logical address</h2>
An address generated by the CPU.<br>
Whereas an address is commonly referred to as <br>
a physical address.<br>
We usually refer to the logical address as a virtual address.
<br>
The set of all logical addresses generated by a program
is a logical address space.<br>
The set of all physical addresses corresponding to these
logical addresses is a physical address space.<br>
Thus, in the execution-time address-binding scheme, the 
logical and physical address spaces differ.
<hr>
<h2>Memory-management unit (MMU)</h2>
The run-time mapping from virtual to 
physical addresses is done by a hardware device.<br>
The base register is now called a relocation register.<br>
The value in the relocation registere is added to<br>
every address generated by a user process at the time<br>
the address is sent to memory.
<hr>
<h2>Dynamic Loading</h2>
To obtain better memory-space utilization.<br>
With dynamic loading, a routine is not loaded <br>
until it is called.<br>
The main program is loaded into memory and is executed.
<hr>
<h2>Dynamic Linking and Shared Libraries</h2>
Dynamic linking is similar to dynamic loading.<br>
Linking,rather than loading, is postpoined until 
execution time.<br>
如果系統中欲執行的程式都須載入主記憶體並連結，會浪費主記憶體，<br>
採用動態連結(Dynamic linking)時，在執行程式碼中要保留<br>
所引用程式庫的索引(Stub)。<br>
索引是一小段的程式碼，用以指示如何找到駐存在記憶體裡的程式。<br>
當執行到這一段索引(Stub)碼時，這段索引碼會把自己代換成真正<br>
欲執行的程式庫位址，並跳到那個位址去執行，下次程式執行<br>
到這個索引碼時，不需要再進行動態連結，就可以直接執行
程式庫。
<hr>
<h2>Swapping</h2>
A process can be swapped temporarily out of memory to<br>
a  backing store and then brought back into memory for<br>
continued execution.<br>
在以優先權為基礎的演算法上，若有一個較高優先權的處理程序到達<br>
並要求服務時，為了載入並執行較高優先權的處理程序執行完成後，<br>
再換回較低優先權的處理程序，則會先把低優先權的程序Swap out。
當Memory有空時，再Swap in較低優先權的處理程序繼續執行。<br>
稱為Roll-In/Roll-Out。
<p>
調換時需要後備儲存體(Backing Store)支援，通常是磁碟。<br>
每當CPU排程程式挑選一個處理程序時，分配程式(Dispatcher)<br>
檢查佇列中下一個處理程序是否在記憶體內，如果不在記憶體裡，<br>
並且記憶體裡沒有空閒的區域，分配程式(Dispatcher)會把目前<br>
在主記憶的低優先權處理程序調換出去，再換進需要的處理程序，<br>
並把控制權交給所選的處理程序。
</p>
<hr>
<h2>Contiguous Memory Allocation</h2>
The main memory must accommodate both the <br>
operating system and the various user processes.<br>
作業系統可以放置在低位址的記憶體空間或高位址記憶體空間，<br>
因為中斷向量通常都位於較低位址空間，所以作業系統通常也<br>
放在較低的位址空間。
<h3>Memory Mapping an Protection</h3>
We can provide these features by using a relocation <br>
register to gether with a limit register.<br>
With relocation and limit registers, each logical address<br>
must be less than the limit register.<br>
The MMU maps the logical address dynamically by adding the<br>
value in the relocation register.<br>
If a device driver is not commonly used, we do not want to<br>
keep the code and data in memory, as we might be able to <br>
use that space for other purposes.<br>
Such code is sometimes called transient(暫態) 
operating-system code.
<hr>
<h2>Allocation Strategy</h2>
假設process大小為n
<ul>
<li>
<b>First-Fit</b><br>
從Available的頭開始找起，直到找到
大小大於等於n的第一個區塊分配給Process為止。
</li>
<li><b>Next-Fit</b><br>
從 AV(Available) List中，上次配置之後的下一個Node開始找起，<br>
直到找到第一個滿足的區塊空間為止。
</li>
<li><b>Best-Fit</b><br>
此方法必須把整個AB串列尋找一次，找到最小且能容納n的區塊。
</li>
<li><b>Worst-Fit</b><br>
AV List找過一次，類似Greedy分配區塊空間。
</li>
</ul>
<h2>缺點</h2>
會產生External Fragementation問題。<br>
產生的Internal Fragemnetation如果過小會直接給這個process。
<hr>
<h2>Paging</h2>
允許一個process的記憶體空間不必連續配置，可避免外部碎裂(external fragementation)。<br>
physical memory被分成許多固定大小的區塊，稱為Frames。<br>
logical memory也被分成許多同樣大小的區塊，稱為Pages。<br>
<img src="img/logical2physical.png" alt=""/>
<h3>缺點</h3>
會有internal fragementation。<br>
需多花時間做logical address 到 physical address轉換。<br>
<h3>Deal with hardware problem</h3>
Transaction lookaside buffers (TLBS)<br>
<img src="img/paging_TLB.png" alt=""/>
<h3>Example hit ratio</h3>
An 80-percent hit ratio, for example, means that we find<br>
the desired page number in the TLB 80 percent of the <br>
time. If it takes 20 nanoseconds to search the TLB and <br>
100 nanoseconds to access memory, then a mapped-memory<br>
access takes 120 nanoseconds when the page number is <br>
in the TLB. If we fail to find the page number in the TLB<br>
(20 nanoseconds), then we must first access memory for the<br>
page table and frame number (100 nanoseconds) and then access<br>
the desired byte in memory(100 nanoseconds), for a total of<br>
220 nanoseconds. To find the 
<b>effective memory-access time</b>, we weight the <br>
case by its probability:<br>
effective access time=<br>
\(
0.80\times(20+100)+0.20\times(20+100+100)
\)<br>
\(
=140
\) nanoseconds.
<hr>
<h2>Shared Pages</h2>
可重入式程式碼(Pure Code)，減少記憶體使用。<br>
<img src="img/share_pages.png" alt=""/>
<hr>
<h1>Page Struture</h1>
<h2>1. MultiLevel paging</h2>
Also called "forward-mapped page table"<br>
\(
p_1 =
\) outer page table<br>
\(
p_2 =
\) offset of outer page.
<br>
<img src="img/page_number.png" alt=""/>
<br>
<img src="img/page_architecture.png" alt=""/>
<br>
<img src="img/twoLevel.png" alt=""/><br>
<hr>
<h2>2. Hashing Page Table</h2>
暫
<hr>
<h2>3. Inverted Page Table</h2>
暫
<hr>
<h2>Segmentation</h2>
d=offset<br>
<img src="img/segmentation.png" alt=""/>
<h3>分段表(Segment Table)</h3>
1. 放在快速暫存器中<br>
當一個程式儲存分段很多時，Cost會太高。<br>
2. 保存在記憶體中<br>
利用Segment Table Base Register(上圖)。<br>
3. 利用TLB(關聯暫存器)來保存。<br>

<footer>
<hr>
<h2>Reference</h2>
Abraham Silberschatz, Greg Gagne, Peter B. Galvin - Operating System Concepts-Wiley<br>
洪逸-作業系統金寶典
</footer>
</body>
</html>
