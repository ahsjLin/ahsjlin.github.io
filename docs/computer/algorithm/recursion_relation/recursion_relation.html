<html>
<head>
<title></title>

<!-- latex math javascript-->
<script 
id="MathJax-script"
async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
</script>
<!-- open raw text -->
<script charset="utf-8">
function graph(name){
	var file = "src/" + name;
	window.open(file);
}
</script>

<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/a/blue.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/table/block.css">



</head>
<body>
Recurrence Relation是為利用自身函數來表達自己函數的方法。<br>
例如:<br>
費式數列(Fibonacci number)<br>
\(
F(n)=F(n-1)+F(n-2)
\)
<hr>
<h2>Substitution Method(替代法)</h2>
策略<br>
<ol>
<li>經驗法則猜結果(asymptotic)</li>
<li>用mathematic induction找出常數(asymptotic的邊界條件)，來證明此猜測是對的。</li>
</ol>
<hr>
<h2>Question</h2>
Determine asymptotic from
\(
T(n)=2T(\lfloor \frac{n}{2} \rfloor)+n,
\;
T(1)=1
\)
<h3>ans</h3>
Guess
\(
T(n)=O(n\lg n)\)<br>
Let
\(
\exists c\in \mathbb{R}
\rightarrow 
T(n)\leq cn\lg n
\)<br> <br>
<b>Mathematic Induction</b><br>
Suppose that \( 
T(\lfloor \frac{n}{2}\rfloor) 
\leq
c\lfloor \frac{n}{2} \rfloor
\lg 
\lfloor \frac{n}{2} \rfloor
\)
existed.<br><br>
\(
\Rightarrow 
T(n)
\leq
2\cdot c\lfloor \frac{n}{2} \rfloor
\lg 
\lfloor \frac{n}{2} \rfloor
+ n
\)<br>
\(
\leq
2\cdot c\frac{n}{2}
\lg 
\frac{n}{2}
+n
\)<br>
\(
=
cn(\lg n-\lg 2)+n
\)<br>
\(
=
cn\lg n - cn\lg 2 +n
\)<br>
(這裡已經可以看出式子在n很大時，\( n\lg n \)為主導。)<br>
when 
\( 
c=2,\;n\geq 2
\rightarrow 
T(2)=2T(1)+2=4\leq 2\cdot 2\lg 2
\) existed.

<hr>
<h2>Recursion-tree Method(遞迴樹法)</h2>
母問題分解成多個子問題，然後子問題當成母問題再繼續分解成多個子問題，直到子問題不能再被分解為止。<br>
<h3>策略</h3>
<ol>
	<li>展開recursion relation</li>
	<li>從母問題分解出來的子問題，那層的子問題的加總，可當作這層的成本花費。</li>
	<li>每層成本加起來，可得到整顆樹的花費。</li>
</ol>
<hr>
<h3>Question</h3>
Give asymptotic tight bound for 
\( T(n)=T(\frac{n}{2})+T(\frac{n}{4})+T(\frac{n}{8})+n \) (assume that \( T(n) \) is constant for sufficiently small \( n \).)
<h3>ans</h3>
將\( T(n) \)展開得<br>
<img src="img/recursion_tree_1.png" alt="ex_1"/> <br>
(第一層為n，是\( T(n)=\dots + {\color{blue} n} \))<br>
再將子問題展開得<br>
<img src="img/recursion_tree_2.png" alt="ex_2"/> <br>
(樹的最左邊層數較多，最右邊層數越少。)<br>
(最右邊直的那排為每層的花費)<br><br>
則總花費為<br>
\( T(n)=n+\frac{7}{8}n+\frac{49}{64}n+\dots+\text{ leaf } \)<br>
當n夠大時，是前面幾項在主導。<br> <br>
計算Big-Oh<br>
\(
\Rightarrow 
T(n)\leq
n+\frac{7}{8}n+\frac{49}{64}n+\dots
=
\frac{n}{1-\frac{7}{8}}
=8n
\)<br>
\(
\Rightarrow 
T(n)=O(n)
\)<br><br>
計算Omega<br>
\( n\leq T(n)=n+\frac{7}{8}n+\frac{49}{64}n+\dots+\text{ leaf } \)<br>
\(
\Rightarrow 
T(n) = \Omega(n)
\)<br><br>
\(
\therefore
T(n)=\Theta(n)
\)
<hr>
<h3>Question</h3>
Given tight asymptotic bounds for \( T(n)=T(n/3)+T(2n/3)+n \)
<h3>ans</h3>
Determine \( \Theta \).<br>
展開\( T(n) \)為<br>
<img src="img/recursion_tree_ex_2_2.png" alt="ex2_2"/><br>
從樹的花費可得知\( T(n) \)的總花費，<br>
為\(
T(n) = \overbrace{n+n+\dots+\text{ leaf}}^{\text{項目個數為最長樹高層數}}.
\)<br>
從上圖的樹可知道\( n/3 \)那條分支最先分完，\( 2n/3 \)最後分完，那就可以知道只要有分支分完，那層的花費加總就不會是\( n \)，就可用來比大小，算出\( O \)和\( \Omega \)。<br><br>
計算Big-Oh:<br>
\(
T(n)=n+n+\dots+\text{ leaf}
\leq
\text{最長樹高}\times n
\)<br>
\(
\Rightarrow 
n
\rightarrow 
\frac{2n}{3}
\rightarrow 
\frac{4n}{9}
\rightarrow 
\frac{8n}{27}
\dots
T(1)
\)<br>
這裡有個想法，n每次都乘\( \frac{2}{3} \)直到變成\( T(1)=1\)<br>
那樹高為，假設為\( h \)<br>
\(
n\cdot (\frac{2}{3})^{h}=1
\)<br>
\(
n=(\frac{3}{2})^{h}
\)<br>
取log<br>
\(
\log_{\frac{3}{2}} n = h\log_{\frac{3}{2}}\frac{3}{2}
=h
\)<br>
\(
\Rightarrow T(n)
\leq
(\log_{\frac{3}{2}} n)\cdot n=O(n\lg n)
\)
<table>
	<tr><th>Hint</th></tr>
	<tr><td>log之間比較order時，不同的底並不影響，<br>
			因為可以用換底公式換成一樣的底。
	</td></tr>
</table>
計算Omega:
找樹高最短的<br>
\(
\Rightarrow 
n\rightarrow 
\frac{n}{3}\rightarrow 
\frac{n}{9}\rightarrow 
\dots
T(1)
\)<br>
假設樹高為h<br>
則<br>
\(
n\cdot(\frac{1}{3})^{h}=1
\)<br>
\(
n=3^h
\)<br>
\(
h=\log_{3}n
\)<br>
<br>
\(
\Rightarrow 
n\cdot(\log_3n)\leq T(n)
\)<br>
\(
\Rightarrow 
T(n)=\Omega(n\lg n)
\)<br> <br>
\(
\therefore T(n)=\Theta(n\lg n)
\)
<hr>
<h2>定理</h2>
由上面兩題得到一個定理。<br>
Given positive constants: \( c_1,c_2,\dots,c_k,c' \),<br>
assume that<br>
\(
T(n)\leq T(c_1n)+T(c_1n)+\dots T(c_kn)+c'n.
\)<br>
If these constant:<br>
<ol>
	<li>
\(
c_1+c_2+\dots+c_k&lt 1, \text{ prove }
T(n)=O(n)
\)
	</li>
	<li>
\(
c_1+c_2+\dots+c_k=1, \text{ prove }
T(n)=O(n\log n)
\)
	</li>
</ol>




<hr>
<footer>
<h2>Reference</h2>
洪捷 - 演算法
</footer>

</body>
</html>
