<html>
<head>
<title></title>

<!-- latex math javascript-->
<script 
id="MathJax-script"
async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
</script>
<!-- open raw text -->
<script charset="utf-8">
function graph(name){
	var file = "src/" + name;
	window.open(file);
}
</script>

<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/a/blue.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/table/block.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/code/code_color.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

</head>
<body>
<h2>1. Two Sum</h2>
<pre><code class="co1">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    *returnSize = 2;
    int *result;
    result = (int *)malloc((*returnSize)*sizeof(int));
    for(int i=0; i&ltnumsSize; i++)
        for(int j=1+i; j&ltnumsSize; j++)
            if(nums[i]+nums[j]==target) {
                result[0] = i;
                result[1] = j;
            }
                
    return result;
}</code></pre>

<hr>
<h2>20. Valid Parentheses</h2>
策略: s指標不動(即字串開頭), p指標持續前進, q指標遇(,[,{則將內容改成),],}且q指標前進, 而其他內容則q後退，最後return看q指標的位址是否是s指標相同。
<pre><code class="co1">bool isValid(char *s) {
	char *q = s;
	for(char *p=s; *p; p++)
		switch(*p) {
			case '(':
				*q++ = ')';
				continue;
			case '{':
				*q++ = '}';
				continue;
			case '[':
				*q++ = ']';
				continue;
			default: 
				if(q==s || *p != *--q) 
					return false;
		}
	return q==s;
}</code></pre>


<hr>


<h2>21. Merge Two Sorted Lists</h2>
hint: 犧牲起始開頭的node。
<pre><code class="co1">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
	struct ListNode *pt, start;
	pt = &start;
	while(list1 && list2) {
		if(list1-&gtval < list2->val) {
			pt-&gtnext = list1;
			list1 = list1-&gtnext;
		} else {
			pt-&gtnext = list2;
			list2 = list2-&gtnext;
		}
		pt = pt-&gtnext;
	}
	// 有個list的內容已經沒有了, 所以跳出while
	pt-&gt next = (list1 ? list1 : list2);
	return start.next;
}</code></pre>

<hr>
<h2>26. Remove Duplicates from Sorted Array</h2>
策略: i和j是nums的index, i持續前進檢查, j只會停在新寫入的index，回傳值是有幾個不同的index。
<pre><code class="co1">int removeDuplicates(int* nums, int numsSize){
	int i,j;
	for(i=1,j=0; i&ltnumsSize; i++)
		if(nums[j]!=nums[i]) nums[++j] = nums[i];
    return ++j;
}</code></pre>







<hr>
<footer>
<h2>Reference</h2>

</footer>

</body>
</html>
