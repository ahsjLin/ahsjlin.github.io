<html>
<head>
<title></title>

<!-- latex math javascript-->
<script 
id="MathJax-script"
async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
</script>
<!-- open raw text -->
<script charset="utf-8">
function graph(name){
	var file = "src/" + name;
	window.open(file);
}
</script>

<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/a/blue.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/table/block.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/code/code_color.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

</head>
<body>
<h2>1. Two Sum</h2>
<pre><code class="co1">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    *returnSize = 2;
    int *result;
    result = (int *)malloc((*returnSize)*sizeof(int));
    for(int i=0; i&ltnumsSize; i++)
        for(int j=1+i; j&ltnumsSize; j++)
            if(nums[i]+nums[j]==target) {
                result[0] = i;
                result[1] = j;
            }
                
    return result;
}</code></pre>

<hr>
<h2>9. Palindrome Number</h2>
<pre><code class="co1">bool isPalindrome(int x){
	long int rev, tmp;
	rev = 0;
	tmp = x;
	while(tmp&gt0){
		rev = rev*10 + tmp%10;
		tmp /= 10;
	}
	return (rev==x && x&gt-1);

}</code></pre>

<hr>
<h2>13. Roman to Integer</h2>
<pre><code class="co1">int checkLastNumber(int now, int last) {
	return ( now&lt=last ? now : now-2*last );
}

int romanToInt(char * s){
	int rev=0;
	int lastValue = rev;
	for(int i=0; i&ltstrlen(s); i++) {
		switch(s[i]) {
			case 'M':
				rev += checkLastNumber(1000, lastValue);
				lastValue = 1000;
				break;
			case 'D':
				rev += checkLastNumber(500, lastValue);
				lastValue = 500;
				break;
			case 'C':
				rev += checkLastNumber(100, lastValue);
				lastValue = 100;
				break;
			case 'L':
				rev += checkLastNumber(50, lastValue);
				lastValue = 50;
				break;
			case 'X':
				rev += checkLastNumber(10, lastValue);
				lastValue = 10;
				break;
			case 'V':
				rev += checkLastNumber(5, lastValue);
				lastValue = 5;
				break;
			case 'I':
				rev += checkLastNumber(1, lastValue);
				lastValue = 1;
				break;
			default: break;
		}
	}
	return rev;
}</code></pre>
<a href="https://leetcode.com/problems/roman-to-integer/discuss/2373950/1LINERFastest-Solution-Explained-O(n)time-complexity-O(n)space-complexity" target="_blank">用Hash Table解法</a>
<hr>
<h2>14. Longest Common Prefix</h2>
<pre><code class="co1">char * longestCommonPrefix(char ** strs, int strsSize){
	int min=INT_MAX;
	int counter = 0;
	char *rev;
	for(int i=0; i&ltstrsSize; i++) {
		min = strlen(strs[i]) &lt min ? strlen(strs[i]) : min;
	}
	for(int i=0; i&ltmin; i++) {
		for(int j=1; j&ltstrsSize; j++) {
			if(strs[0][i]!=strs[j][i]) {
				min = 0;
				counter--; //寫這個的原因是要讓下面的counter增加，而下面的counter一定要增加，因為如果傳進來的strs只有一個字串且一個字元, 這裡的for就不會run, 分配的空間'\0'需要佔一char，所以下面calloc分配的空間要再加一。
				break;
			}
		}
		counter++;
	}
	rev = (char *)calloc((++counter), sizeof(char));
	snprintf(rev, counter, "%s", *strs);
	return rev;
}</code></pre>
<hr>
<h2>20. Valid Parentheses</h2>
策略: s指標不動(即字串開頭), p指標持續前進, q指標遇(,[,{則將內容改成),],}且q指標前進, 而其他內容則q後退，最後return看q指標的位址是否是s指標相同。
<pre><code class="co1">bool isValid(char *s) {
	char *q = s;
	for(char *p=s; *p; p++)
		switch(*p) {
			case '(':
				*q++ = ')';
				continue;
			case '{':
				*q++ = '}';
				continue;
			case '[':
				*q++ = ']';
				continue;
			default: 
				if(q==s || *p != *--q) 
					return false;
		}
	return q==s;
}</code></pre>


<hr>


<h2>21. Merge Two Sorted Lists</h2>
hint: 犧牲起始開頭的node。
<pre><code class="co1">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
	struct ListNode *pt, start;
	pt = &start;
	while(list1 && list2) {
		if(list1-&gtval < list2->val) {
			pt-&gtnext = list1;
			list1 = list1-&gtnext;
		} else {
			pt-&gtnext = list2;
			list2 = list2-&gtnext;
		}
		pt = pt-&gtnext;
	}
	// 有個list的內容已經沒有了, 所以跳出while
	pt-&gt next = (list1 ? list1 : list2);
	return start.next;
}</code></pre>

<hr>
<h2>26. Remove Duplicates from Sorted Array</h2>
策略: i和j是nums的index, i持續前進檢查, j只會停在新寫入的index，回傳值是有幾個不同的index。
<pre><code class="co1">int removeDuplicates(int* nums, int numsSize){
	int i,j;
	for(i=1,j=0; i&ltnumsSize; i++)
		if(nums[j]!=nums[i]) nums[++j] = nums[i];
    return ++j;
}</code></pre>

<hr>
<h2>27. Remove Element</h2>
<pre><code class="co1">int removeElement(int* nums, int numsSize, int val){
    int counter=numsSize;
    int i;
    for(i=0; i&ltcounter;)
	    if(nums[i]==val){ 
			    nums[i] = nums[counter-1];
                counter--;
		} else 
            i++;
    return counter;
}</code></pre>
<hr>
<h2>28. Implement strStr()</h2>
If it can work. Don't touch it!
<pre><code class="co1">int strStr(char * haystack, char * needle){
	int s1=strlen(haystack);
	int s2=strlen(needle);
	int i,j;
	for(i=0;i&lts1;i++) {
		if(haystack[i]==needle[0]) {
			if((i+s2-1)&lts1) {
				for(j=0;j&lts2;j++) {
					if(haystack[j+i]!=needle[j]) {
						j++;
						break;
					}
				}
				j--; 
				if(haystack[j+i]==needle[j])
					return i;
			}
		}
	}
	return -1;
}</code></pre>

<hr>
<h2>35. Search Insert Position</h2>
<pre><code class="co1">int searchInsert(int* nums, int numsSize, int target){
	int i;
	for(i=0; i&ltnumsSize; i++) 
		if(target&lt=nums[i])
			break;
	return i;
}</code></pre>


<hr>
<h2>58. Length of Last Word</h2>
<pre><code class="co1">int lengthOfLastWord(char * s){
	int lastIndex = strlen(s)-1;
	int counter = 0;
	for(int i=lastIndex; i&gt=0; i--)
		if(s[i]==' ' && counter!=0)
			break;
		else if(s[i]!=' ')
			counter++;
	return counter;
}</code></pre>

<hr>
<h2>66. Plus One</h2>
這裡returnSize指的是回傳陣列的size, 並不是回傳值。
<pre><code class="co1">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* plusOne(int* digits, int digitsSize, int* returnSize){
	digits[digitsSize-1]++;
	for(int i=digitsSize-1; i&gt0 && digits[i]&gt=10; i--) {
		digits[i] -= 10;
		digits[i-1] += 1;
	}
	int *rev = digits;
	*returnSize = digitsSize;
	if(digits[0]&gt=10) {
		digits[0] -=10;
		rev = (int *)calloc(++*returnSize, sizeof(int));
		rev[0] = 1;
		memcpy(rev+1, digits, digitsSize*sizeof(int));
	}
	return rev;
}</code></pre>
<hr>
<h2>67. Add Binary</h2>
<pre><code class="co1">char * addBinary(char * a, char * b){
	int sizeA = strlen(a);
	int sizeB = strlen(b);
	int sizeOutput = (sizeA &gt sizeB ? sizeA : sizeB) + 1; // 可能進位, 所以預留一格(size+1)。
	char *output = (char *) malloc(sizeOutput*sizeof(char)+1); // 需要留一個'\0'的字元 所以多分配一個byte。
	int sum=0;

	output[sizeOutput] = '\0';

	/* sizeA和sizeB計算完了，sum可能還需要計算進位的值。 */
	while(sizeA&gt0 || sizeB&gt0 || sum&gt0) { 
		if(sizeA&gt0)
			sum += a[--sizeA] - '0';
		if(sizeB&gt0)
			sum += b[--sizeB] - '0';
		output[--sizeOutput] = sum%2 + '0';
		sum /=2;
	}
	/* 這邊回傳output的位址加sizeOutput, 是因為如果沒進位, sizeOutput值是1,
	   而進位的那格會是亂碼，那從output[1]的位址回傳就行了。 
	*/
	return output + sizeOutput;
} </code></pre>


<hr>
<h2>69. Sqrt(x)</h2>
<pre><code class="co1">int mySqrt(int x){
	int rev;
	if(x&lt=1) return x;
	for(long int i=1; i*i&lt=x; i++)
		rev = i;
	return rev;
}</code></pre>

<hr>
<h2>70. Climbing Stairs</h2>
<pre><code class="co1">int climbStairs(int n){
	int ways = 0;
	int lastFirst=2, lastSec=1;
	if(n==0 || n==1 || n==2) return n;
	for(int i=3; i&lt=n; i++){
		/* calculate ways */
		ways = lastFirst + lastSec;

		/* prepare for next steps */
		lastSec = lastFirst;
		lastFirst = ways;
	}
	return ways;
}</code></pre>

<hr>
<h2>83. Remove Duplicates from Sorted List</h2>
<pre><code class="co1">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* deleteDuplicates(struct ListNode* head){
	if(head==NULL) return NULL;
	struct ListNode *p, *q;
	/* p keep forward, q remark pointer */
	p = q = head;
	while(q-&ltnext) {
		if(q-&ltval == q-&ltnext-&ltval) {
			p = q-&ltnext-&ltnext;
			free(q-&ltnext);
			q-&ltnext = p;
		} else {
			q = q-&ltnext;
		}
	}
	return head;
} </code></pre>







<hr>
<footer>
<h2>Reference</h2>

</footer>

</body>
</html>
