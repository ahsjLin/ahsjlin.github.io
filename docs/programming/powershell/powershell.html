<html>
<head>
<title>Powershell</title>

<!-- latex math javascript-->
<script 
id="MathJax-script"
async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
</script>
<!-- open raw text -->
<script charset="utf-8">
function graph(name){
	var file = "src/" + name;
	window.open(file);
}
</script>

<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/a/blue.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/table/block.css">
<link rel="stylesheet" type="text/css" href="https://ahsjlin.github.io/html_head/css/code/code_color.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<style>
table.tmp_table tr {
	text-align: center;
}
table.tmp_table tr td {
	width: 70px;
}
</style>

</head>
<body>
<h2>Create Object</h2>
<pre><code class="co1">
# example 1
$var = New-Object System.DateTime

# example 2
$newObject = [PSCustomObject]@{
	ComputerName	= 'Server1'
	Role		= 'Interface'
	Environment	= 'Production'
}

</code></pre>
<hr>
<h2>Split variable</h2>
<pre><code class="co1">$intput = "foo.baz,bar"
$part = $input.Split(".")
$fooVar = $part[0]
$bazVar = $part[1]
$barVar = $part[2]

# simply do this
$foo, $baz, $bar = $input.Split(".")

# whatif number of variables is less than splits.
$foo, $sec = $input.Split(".")
# $foo == foo, $sec = ["baz", "bar"]
</code></pre>
<hr>
<h2>Scope(global and local)</h2>
<pre><code class="co1">$foo = "global"
function myFunc {
	$foo = "local"
	Write-Host $global:foo 	# global
	Write-Host $local:foo 	# local
	Write-Host $foo		# local
}
# call function
myFunc
Write-Host $local:foo 	# global
Write-Host $foo 	# global
</code></pre>
<hr>
<h2>Remove Variable</h2>
<pre><code class="co1">
$var = "something in here"

# remove it
Remove-Variable -Name var
# or
rv var
</code></pre>
<hr>
<h2>Operators</h2>
Comparision Operators
<pre><code class="co1">
-eq ==
-ne !=
-gt &gt
-ge &gt=
-lt &lt
-le &lt=

# example 
# 5 -eq 5

#-----------------------------

# String comparison operators
"myString" -like "*String"
"myString" -nolike "Other*"
"myString" -match '^String$'
"myString" -nomatch '^Other$'


#-----------------------------

# Collection comparison operators
"abc", "def" -contains "def" 		# return true
"abc", "def" -notcontains "123"		# return true
"def" -in "abc", "def"			# return true
"123" -notin "abc", "def"		# return true

</code></pre>

Arithmetic Operators
<pre><code class="co1">
+
-
-1 # set negative value
*
/
%

# Bitwise
100 -shl 2 # Bitwise Shift-left
100 -shr 1 # Bitwise Shift-right

#------------------------------
# Assignment Operators
$var = 1
$var += 1

...

$var++
$var--

</code></pre>


<hr>
<h2>Mixing operand types</h2>
<pre><code class="co1">
# For Addition
"4" + 2 	# 42
4 + "2" 	# 6
1,2,3 + "Hello"	# 1,2,3,"Hello"
"Hello" + 1,2,3 # "Hello1 2 3"

# For Multiplication
"3" * 2 	# "33"
2 * "3"		# 6
1,2,3 * 2	# 1,2,3,1,2,3
2 * 1,2,3	# error
</code></pre>
<hr>
<h2>Read Input</h2>
<pre><code class="co1">
$a = Read-Host "Enter a number:"
# assigned value into $a
</code></pre>
<hr>
<hr>
<h2>Logical Operator</h2>
<pre><code class="co1">
-and 
-or 
-xor 	# exclusive or
-not 
! 	# not
</code></pre>
<hr>
<h2>Replace Operator</h2>
<pre><code class="co1">
"The rain in Seattle." -replace 'rain' 'hail' # return "The hail in Seattle."
</code></pre>
<hr>
<hr>
<h2>split and join</h2>
<pre><code class="co1">
"A B C" -split " "  		# Return an array string

"E", "F", "G" -join ":" 	# Return a single string, E,F,G
</code></pre>

<hr>
<h2>Where</h2>
<pre><code class="co1">Where-Object
where
?</code></pre>
<hr>
<hr>
<h2>Select</h2>
<pre><code class="co1">
$dir = dir "C:\myDir"

$dir | select Name, FullName, Attributes
</code></pre>
<hr>
<h2>Foreach</h2>
shorthand syntax == %
<pre><code class="co1">$Numbers = ForEach ($Number in 1..20) {
	$Number
}</code></pre>
<pre><code class="co1">(1..10).ForEach{$_ * $_}
# output
1
4
9
16
25

...
</code></pre>
<hr>
<h2>Break Labels</h2>
<pre><code class="co1">$i = 0
:mainLoop While($i -lt 15) {
	$j = 0
	While($j -lt 15) {
		if($i -gt 10) {
			break mainLoop
		}
		$j++
	}
	$i++
}</code></pre>
<hr>
<h2>while application</h2>
<pre><code class="co1">Start-Process notepad.exe
while(Get-Process notepad -ErrorAction SilentlyContinue) {
	Start-Sleep -Milliseconds 500
}</code></pre>
<hr>
<h2>switch</h2>
<pre><code class="co1">switch($val){
	'First condition' 	{First action}
	'Second condition'	{Second action}
	Default			{}
}</code></pre>
Case Sensitive
<pre><code class="co1">switch -CaseSensitive ('Condition'){
	'condition' 	{First action}
	'Condition'	{Second action}
	Default		{}
}
# output: Second action
</code></pre>
Wildcard
<pre><code class="co1">switch -Wildcard ('Condition') {
	'Condition'		{first}
	'Condit*'		{second}
	'C[aeo]ndit[f-l]on'	{third}
	'C?ndition'		{fourth}
	'Test*'			{fifth}
	Default			{}
}</code></pre>
File
<pre><code class="co1"># input.txt
# condition
# test

switch -file input.txt
{
	'condition'	{First}
	'test'		{Second}
	'fail'		{Third}
	Default		{}
}

# output
# First
# Second
</code></pre>

<hr>
<h2>Special characters</h2>
<pre><code class="co1">
`0	# NUll
`a 	# Alert/Beep
`b 	# Backspace
`f 	# Form feed (used for printer output)
`n 	# New line
`r	# Carriage return
`t 	# Horizontal tab
`v 	# Vertical tab (used for printer output)


`#	# Comment-operator
`$	# Variable operator
``	# Escape character
`'	# Single quote
`"	# Double quote

</code></pre>
<hr>
<h2>Create new object</h2>
<pre><code class="co1">
$newArr = @()
$newArr += New-Object -TypeName PSObject -Property @{
	Name 	= $env:username
	ID	= 12
	Address	= $null
}
</code></pre>
<hr>
<hr>
<h2>Function with Parameters</h2>
<pre><code class="co1">
function write-greeting {
	param(
		[Parameter(Mandatory, Position=0)]
		[String]$name
		[Parameter(Mandatory, Position=1)]
		[Int]$age
	)
	"Hello $name, you are $age years old"
}



or simple function



function write-greeting($name, $age) {
	"Hello $name, you are $age years old"
}




# The order of the parameters on the invocation 
# is matched to the order of the declaration in the function header(by default),
# or can be specified using the Position Parameter Attribute.
$greeting = Write-Greeting "Jim" 82

# Alternatively
$greeting = Write-Greeting -name "Bob" -age 82

</code></pre>
cmdletbinding - function will behave like a cmdlet
<pre><code class="co1">
function Verb-Noun
{
	[Cmdletbinding(DefaultParameterSetName='Parameter Set 1', 
		SupportsShouldProcess=$true,
		PositionalBinding=$false,
		HelpUri = 'http://www.microsoft.com/',
		ConfirmImpact='Medium'
	)]

	...

}</code></pre>
<h3>Mandatory Parameters</h3>
<pre><code class="co1">function Get-Greeting {
	param
	(
		[Parameter(Mandatory=$true)]$name
	)
	"Hello World $name"
}</code></pre>
<pre><code class="co1"># the command line will prompt for the value
$greeting = Get-Greeting </code></pre>
<h3>ValidateSet</h3>
Need to restrict the possible values that a parameter can accept.
<pre><code class="co1">param(
	[ValidateSet('red', 'green', 'blue', IgnoreCase)]
	[string]$Color
) </code></pre>
<h3>ValidateRange</h3>
<pre><code class="co1">param(
	[ValidateRange(0,120)]
	[Int]$Age
) </code></pre>
<h3>ValidatePattern</h3>
<pre><code class="co1">param(
	[ValidatePattern("\w{4-6}\d{2}")]
	[string]$UserName
) </code></pre>
<h3>Validatelength</h3>
<pre><code class="co1">param(
	[ValidateLength(0,15)]
	[String]$PhoneNumber
) </code></pre>
<h3>ValidateCount</h3>
This method of parameter validation tests the amount of arguments passed in, for example, an array of strings.
<pre><code class="co1">param(
	[ValidateCount(1,5)]
	[String[]]$ComputerName
) </code></pre>
<h3>ValidateScript</h3>
Finally, the ValidateScript method is extraordinarily flexible, taking a scriptblock and evaluating it using $_ to represent the passed argument.
It then passes the argument if the result is $true (including any output as valid).<br>
<br>
This can be used to test that a file exists:
<pre><code class="co1">param(
	[ValidateScript({Test-Path $_})]
	[IO.FileInfo]$Path
) </code></pre>
<pre><code class="co1">param(
	[ValidateScript({Get-ADUser $_})]
	[String]$UserName
) </code></pre>
<hr>
<h2>listing available constructors for a class</h2>
You can list available constructors by calling the static new-method without parethese.
<pre><code class="co1">[DateTime]::new
OverloadDefinitions                                                            
-------------------                                                            
datetime new(long ticks)                                                       
datetime new(long ticks, System.DateTimeKind kind)                             
datetime new(int year, int month, int day)                                     
datetime new(int year, int month, int day, System.Globalization.Calendar       
calendar)                                                                      
datetime new(int year, int month, int day, int hour, int minute, int second)   
datetime new(int year, int month, int day, int hour, int minute, int second,   
System.DateTimeKind kind)                                                      
datetime new(int year, int month, int day, int hour, int minute, int second,   
System.Globalization.Calendar calendar)                                        
datetime new(int year, int month, int day, int hour, int minute, int second,   
int millisecond)                                                               
datetime new(int year, int month, int day, int hour, int minute, int second,   
int millisecond, System.DateTimeKind kind)                                     
datetime new(int year, int month, int day, int hour, int minute, int second,   
int millisecond, System.Globalization.Calendar calendar)                       
datetime new(int year, int month, int day, int hour, int minute, int second,   
int millisecond, System.Globalization.Calendar calendar, System.DateTimeKind   
kind)                 
</code></pre>
<hr>
<h2>Methods and properties</h2>
<pre><code class="co1">class Person {
	[string] $FirstName
	[string] $LastName
	[string] Greeting() {
		return "Greetings, {0} {1}" -f $this.FirstName, $this.LastName
	}
}

$x = [Person]::new()
$x.FirstName = "Jane"
$x.LastName = "Doe"
$greeting = $x.Greeting() # output: "Greetings, Jane Doe!"

</code></pre>
<h3>Overloading</h3>
<pre><code class="co1">class Person {
	[string] $name
	[int] $age

	Person([string] $name) {
		$this.name = $name
	}

	Person([string]$name, [int]$age) {
		$this.name = $name
		$this.age n $age
	}
}</code></pre>
<hr>
<h3>Inheritance from Parent class to Child class</h3>
<pre><code class="co1">class ParentClass 
{
	[string] $meg = "It's under the parent class"
	[string] getMessage()
	{
		return ("Message: {0}" -f $this.meg)
	}
}

# bar extends Foo and inherits its members
class ChildClass : ParentClass
{
	
}


$Inherit = [ChildClass]::new()
</code></pre>
so, <code>$Inherit.meg</code> will give you the "It's under the Parent Class"
<hr>
<h2>Create a Module Manifest</h2>
<pre><code class="co1">@{
	RootModule = 'myModule.psm1'
	ModuleVersion = '1.0'
	CompatiblePSEditions = @('Core')
	GUID = '6382 ... 32x'
	Author = 'Bob'
	CompanyName = 'myCompany'
	Copyright = '(c) 2018 all rights'
	Description = 'It's description.'
	FunctionsToExport = @()
	CmdletsToExport = @()
	VariablesToExport = @()
	AliasesToExport = @()
	DscResourcesToExport = @()
} </code></pre>
<hr>
<h2>Simple Module Example</h2>
<pre><code class="co1">function Add {
	[CmdletBind()]
	param (
		[int] $x
		[int] $y
	)

	return $x + $y
}

Export-ModuleMember -Function Add
</code></pre>
<hr>
<h2>PowerShell profiles</h2>
A PowerShell profile is used to load user defined variables and functions automatically.<br>
PowerShell profiles are not automatically created for users.
<pre><code class="co1">$PROFILE | Format-List -Force
$PROFILE.AllUsersAllHosts</code></pre>
<hr>
<h2>Calculated Properties</h2>
Display file properties.
<pre><code class="co1">Get-ChildItem -Path C:\myDir | Select-Object Name, CreateTim, Length 

# calcualted properties
Get-ChildItem -Path C:\myDir | Select-Object Name, @{name="Size_In_KB"; Expression={$_.Length / 1Kb}}


</code></pre>

<hr>
<h2>Using the .Net Math Class</h2>
Knowing which methods are available you can use:
<pre><code class="co1">[System.Math] | Get-Member -Static -MemberType Methods</code></pre>
Examples
<pre><code class="co1">[System.Math]::Floor(9.33) # 9
[System.Math]::Ceiling(9.333) # 10
[System.Math]::Pow(4,3) # 64
[System.Math]::Sqrt(49) # 7</code></pre>
<hr>
<h2>Variables</h2>
<h3>$PSItem</h3>
Same as $_.
<pre><code class="co1">Get-Process | ForEach-Object -Process {
	$PSItem.Name
}</code></pre>
<h3>$?</h3>
Contains the execution status of the last operation.<br>
It contains TRUE if the last operation succeeded and FALSE if it failed.<br>
Contains status of the last operation. When there is no error, it is set to Treu.
<pre><code class="co1">Write-Host "yes yes"
$? # True</code></pre>
<pre><code class="co1">Get-Process -Name nooo
Write-Host -Object "Was the last operation successful? $?"</code></pre>
<h3>$error</h3>
Contains an array of error objects that represent the most recent errors.
<pre><code class="co1">Get-Process -Name noooo
Write-Host -Object ('The last error that occurred was: {0}', -f $error[0].Exception.Message)</code></pre>
Remove error
<pre><code class="co1">$error.remove($error[0]) </code></pre>

<h3>$OFS</h3>
Converting an array to a string. By default $OFS = " "
<pre><code class="co1">$arr = 1, 2, 3
$OFS = ",."

$arr # 1,.2,.3</code></pre>
<hr>
Contains process ID of the current hosting process.
<pre><code class="co1">$pid </code></pre>

<hr>
<h2>Splatting parameters</h2>
<pre><code class="co1">$MyParameters = @{
	Name = "iexplore"
	FileVersionInfo = $true
}</code></pre>

# splatting
Get-Process @MyParameters

# without splatting
Get-Process -Name "iexplore" -FileVersionInfo
<hr>
<h2>Write Preferences</h2>
<pre><code class="co1">Write-Verbose "Detailed message"
Write-Information "Information Message"
Write-Debug "Debug Message"
Write-Progress "Progress Message"
Write-Warning "Warning Message"</code></pre>
<hr>
<h2>Basic job creation</h2>
<pre><code class="co1"># Start a Script Block as background job: 
$job = Start-Job -ScriptBlock {Get-Process}

# Start a script as background job
$job = Start-Job -FilePath "C:\yourScript.ps1"
</code></pre>
<hr>
<h2>Error Handle</h2>
<pre><code class="co1">Try
{
	... Something Error ...
	Stop-Process -Id 123456 -ErrorAction Stop
}
Catch
{
	... Do Something ...
	"Non-Terminating Error: Invalid Process ID"
}</code></pre>
<hr>
<h2>Credential</h2>
輸出加密檔案xml
<pre><code class="co1">$credential = get-credential
$credential | Export-CliXml -Path 'C:\yourPath\cred.xml'</ode></pre>
import加密檔案
<pre><code class="co1">$credential = Import-CliXml -Path 'C:\yourPath\cred.xml' </code></pre>

<hr>
<hr>
<h2>get-command</h2>
<pre><code class="co1">
# It will display all s*.
get-command -Noun s*
</code></pre>







<hr>
<footer>
<h2>Reference</h2>

</footer>

</body>
</html>
